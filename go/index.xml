<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gos on To Be A Better Man</title>
    <link>https://gru.tsecloud.club/go/</link>
    <description>Recent content in Gos on To Be A Better Man</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Mar 2019 22:47:12 +0800</lastBuildDate>
    
	<atom:link href="https://gru.tsecloud.club/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GoLang-Map</title>
      <link>https://gru.tsecloud.club/go/map/</link>
      <pubDate>Thu, 28 Mar 2019 22:47:12 +0800</pubDate>
      
      <guid>https://gru.tsecloud.club/go/map/</guid>
      <description>map是Go语言的一种内建类型，该类型将一个键和值相互关联起来，通过该键获取其所存储的值。因此我们首先遇到的问题是，哪些类型能够作为key来进行使用,总的来说，所有可以直接使用比较操作符(比如: ==,!=,&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=)进行比较的类型，都可以用来作为key来使用。
 布尔值（bool） 整型（integer） 浮点型(float) 复数 字符串 指针 channel (通道)值 interface(接口) struct(结构体) array(数组)  map的声明 对于一个map来说，其元素由key和value组成，因此一个map的声明如下
var m map[string]string  其通用表达式为map[Key_Type]value_type ,map的零值为nil ,为了验证这个问题，可以做如下的实验
var m map[string]string if m == nil { fmt.Println(m) } else { fmt.Println(&amp;quot;b&amp;quot;) }  以上结果将会直接输出map[]，但是我们无法在其中添加元素，因为map的零值为nil,为了解决这个问题，可以有一下两种方式
 使用make函数来进行声明
var m = make(map[string]string) if m == nil { fmt.Println(&amp;quot;a&amp;quot;) } else { fmt.Println(m) //将会输出:map[] }  声明的时候，直接进行赋值
var m = map[string]string{ &amp;quot;a&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;: &amp;quot;b&amp;quot;, } if m == nil { fmt.</description>
    </item>
    
    <item>
      <title>GoLang-切片</title>
      <link>https://gru.tsecloud.club/go/slice/</link>
      <pubDate>Wed, 27 Mar 2019 20:10:55 +0800</pubDate>
      
      <guid>https://gru.tsecloud.club/go/slice/</guid>
      <description>​ 由于数组的长度属性属于数组类型的一部分，因此限定了数组的灵活性，为了解决这个问题，Golang中引入了切片作为数组的一个补充。切片本身不存储任何的数据，它只是底层数组的一个反射，因此对于切片的修改将直接作用到底层的数组上。
切片的属性 对于切片而言，长度，容度是我们特别重要的两个属性
 长度，指的是切片中元素的数量，可以使用len函数获取 容度，指的是切片创建的时候从切片起始位置到数组末尾所占元素的总和，可以使用cap函数获取  因此，对于一个切片而言，其长度&amp;lt;=容度
切片的声明  使用内置的make函数直接生成  s := make([]int, 3, 4) fmt.Println(s)  使用make函数创建切片的时候可表达为make([]T,len,cap)，
 []T 用来指明切片底层数组所保存的元素类型。 len 用来标识切片底层数组的长度。 cap代表的是切片的容度,通常可省略，省略的时候切片的长度=容度  实际在创建一个切片的时候会先创建一个底层数组，然后将底层数组反射成切片
 基于已存在的数组，直接生成切片  a := [...]int{1, 2, 3, 4, 5, 6} s := a[2:4]  以上将会输出[3 4], 基于数组创建切片的时候，切片的取值范围通用表达式为arr[start:end]
 start的值决定了切片的容度大小
 end 的值的取值范围为0~len(arr)
 如果需要取最前端或者最末端的时候，可以留空,比如[:],[start:],[:end]
 当创建切片以后，切片中的元素所以将会重新从0开始编号
   基于已存在的切片来创建  a := [...]int{1, 2, 3, 4, 5, 6} s1 := a[4:4] fmt.</description>
    </item>
    
    <item>
      <title>GoLang-数组</title>
      <link>https://gru.tsecloud.club/go/array/</link>
      <pubDate>Tue, 26 Mar 2019 22:25:25 +0800</pubDate>
      
      <guid>https://gru.tsecloud.club/go/array/</guid>
      <description>数组声明 由于Go语言是一种强类型的语言，所有的变量都必须先声明后使用，因此数组的声明有以下几种方式:
 先声明数量和类型，未赋值的话，将初始化未数组元素类型的零值。
var a [2]int  声明的时候，同时赋值,未赋值的元素，将使用元素的零值
var a = [2]int{2}  利用编译的时候自动推导出数组的长度，因此可以使用...来省略数组的长度
var a = [...]int{2, 3, 4}  当然也可以使用短语法来声明一个数组
a := [...]int{2,3}   数组类型 在Go中，数组表示相同类型的元素集合，数组是一种类型，简写为:n[T],由此可见，数组这种类型是由数量n和类型[T]两部分组成的,包含相同类型，但是元素不同的两个数组属于两个不同的数组类型
var a = [2]int{2, 3} var b = [2]int{2} var c = [1]int{3} b = a c = a //将会报错误:cannot use a (type [2]int) as type [1]int in assignment fmt.Println(a, b, c)  以上，将数组a赋值给b是允许的，因为他们的元素类型和元素数量相同，反之，将a赋值给c是不被允许的，虽然他们的元素的类型相同，但是他们的元素的数量不一致，因此他们属于不同的数组类型。
由于数组在Go中是一种值类型而不是反射类型，因此当我们将数组赋值给一个变量的时候，实际上是对原数组进行一个复制，对于新数组的变更，将不会作用与旧的数组，看下面一个例子
var a = [...]int{2, 3, 4} b := a fmt.</description>
    </item>
    
    <item>
      <title>Goroutine</title>
      <link>https://gru.tsecloud.club/go/goruotine/</link>
      <pubDate>Tue, 13 Feb 2018 21:52:57 +0800</pubDate>
      
      <guid>https://gru.tsecloud.club/go/goruotine/</guid>
      <description>Goroutines  Goroutine是由Go runtime管理的轻量级线程，开启一个新的Goroutine只需要使用go关键字，由于Goroutine运行在相同的地址空间，因此需要通过共享内存实现同步，包sync提供了基本的同步操作
 Channels  Channel是一种管道类型，使用它可以通过箭头操作符(&amp;lt;-)发送和接受数据
 默认情况下通过Channel发送、接收是阻塞的，也就是说，Channel的容量是1，举例来说，假设你通过channel发送一个值，如果另外一端不读取数据，那么再次发送数据就是阻塞的，必须等到另外一端接受数据后才能继续发送数据，该机制能够保证数据的同步不需要依赖于显示锁或者是状态值
func main() {c := make(chan int)for i := 0; i &amp;lt; 3; i++ {signCapChan(i, c)}y := &amp;lt;-cfmt.Println(y)}func signCapChan(x int, ch chan int) {ch &amp;lt;- x} 上面的程序将会提示all goroutines are asleep - deadlock!
为了解决这个容量问题，我们需要给channel引入缓存的概念，直接在初始化的时候，给定其容量的大小，因此上面的问题可以如下解决
....c := make(chan int, 3).... 按照上面的调整以后，程序可以正常运行，但是如果将channel的容量变更为2,依旧会出现：all goroutines are asleep - deadlock!的错误,原因在于,对于一个有缓存的channel来说，当往其中写入数据的时候，如果容量满了以后，依旧会发生阻塞，在读取的情况下，如果channel为空的情况下依旧会发生阻塞
...y := &amp;lt;-cfor i := 0; i &amp;lt; 3; i++ {signCapChan(i, c)}fmt.</description>
    </item>
    
    <item>
      <title>The HTTP Caddyfile</title>
      <link>https://gru.tsecloud.club/go/http-caddyfile/</link>
      <pubDate>Tue, 06 Feb 2018 23:54:27 +0800</pubDate>
      
      <guid>https://gru.tsecloud.club/go/http-caddyfile/</guid>
      <description>站点地址(Site Addresses) HTTP服务使用站点地址作为labels层，地址的形式为scheme://host:port/path,当你填写地址的时候，可以选择其中的 一部分进行使用
host:port通常是localhost或者是站点的域名，如果使用默认的https模式(此时端口号为：443),那么默认的端口号是2015 在某种意义上来说，协议代表着所使用的端口号，比如：http代表使用80端口， https代表使用443端口，如果协议和端口号都进行 指定，那么指定的优先级将会高于协议所默认的端口号。如下表格假设使用了自动使用https模式下，指定不同的格式所使用的端口号
:2015 # Host: (any), Port: 2015 localhost # Host: localhost; Port: 2015 localhost:8080 # Host: localhost; Port: 8080 example.com # Host: example.com; Ports: 80-&amp;gt;443 http://example.com # Host: example.com; Port: 80 https://example.com # Host: example.com; Ports: 80-&amp;gt;443 http://example.com:1234 # Host: example.com; Port: 1234 https://example.com:80 # Error! HTTPS on port 80 *.example.com # Hosts: *.example.com; Port: 2015 example.com/foo/ # Host: example.com; Ports: 80, 443; Path: /foo/ /foo/ # Host: (any), Port: 2015, Path: /foo/  需要注意的是，站点域名地址必须唯一，对同一个域名的配置，必须放在相同的语句块内</description>
    </item>
    
    <item>
      <title>Golang Middleware Part 1</title>
      <link>https://gru.tsecloud.club/go/middleware_part_1/</link>
      <pubDate>Tue, 06 Feb 2018 23:30:40 +0800</pubDate>
      
      <guid>https://gru.tsecloud.club/go/middleware_part_1/</guid>
      <description>如何在Golang中实现中间件-Part 1 当使用net/http包实现服务的时候，一般使用的是如下的两中处理方式:
 http.HandleFunc http.Handle  http.HandleFunc 分析 当使用这种方式的时候，其接受两个参数，一个是字符串格式的匹配符(pattern),另外一个就是func(ResponWrite, *Request), 因此只要我们的中间件中返回该类型，那么中间件就是可以实现的
func main(){http.HandleFunc(&amp;#34;/&amp;#34;, Hello)http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil)}func Hello(w http.ResponseWriter, r *http.Request) {fmt.Print(&amp;#34;hello&amp;#34;)} 当我们运行如上的程序的时候，就会打印出hello这个结果，说明我们的写法是没有问题的
实现 接下来，我们需要定义我们的中间件，它需要接收一个｀ http.HandlerFunc｀类型，并且返回一个http.HandlerFunc这样才能被使用
func MyMiddleware(next http.HandlerFunc)http.HandlerFunc {return func(w http.ResponseWriter, r *http.Request) {fmt.Println(&amp;#34;middleware&amp;#34;)//doSomethinds	next.ServeHTTP(w,r)}} 由于调用next.ServeHTTP(w, r)等效于调用next(w, r),处理完后会返回响应w,最终相应会传递到最外层的匿名函数，从而最终会返回到客户端
http.Handle 分析 http.Handle接受两个参数，一个是匹配符，另外一个是http.Handler，当我们查看源码的时候，发现其是一个接口类型
type Handler interface {ServeHTTP(ResponseWriter, *Request)} 因此我们最终得返回一个实现了该接口的类型，假设我们首先定义一个新的结构体,并为其添加一个｀ServiceHTTP｀
解决 type MyResponse struct {next http.HandleCode int64Msg stringErrors []stringData map[string]interface{}}func (res *MyResponse)ServeHTTP(w http.</description>
    </item>
    
    <item>
      <title>Caddyfile</title>
      <link>https://gru.tsecloud.club/go/caddyfile/</link>
      <pubDate>Wed, 31 Jan 2018 23:07:05 +0800</pubDate>
      
      <guid>https://gru.tsecloud.club/go/caddyfile/</guid>
      <description>该文章将会向你展示使用Caddyfile配置Caddy是一件十分简单的事情
Caddyfile是一个文本文件，用来配置Caddy如何运行
该文件的第一行永远是服务站点的地址，比如:
localhost:8080  当你保存以后，一旦启动caddy服务器，那么将会自动查找Caddyfile文件，并加载其中的配置 默认情况会在当前的目录下面查找Caddyfile文件，如果将配置文件放置在其他的地方，那么在 启动的时候，需要指明Caddyfile文件所在的路径
caddy -conf ../path/to/Caddyfile  紧跟着站点地址的下一行则是指令，Caddy提供了丰富的指令 比如: gzip则是一个HTTP指令
localhost:8080 gzip log ../access.log  有一些指令需要使用多行进行配置，这个时候需要使用{}进行配置，而且{必须在指令的行尾
localhost:8080 gzip log ..access.log markwodn /blog { css /blog.css js /scripts.js }  如果{}里面不进行设置，那么则应该省略 如果配置参数的值包含空白符，那么则应该使用&amp;quot;&amp;quot;进行包裹
当然caddyfile文件中也可以以#开头，添加注释
# 注释可以单独作为一行 foobar #也可以放在配置的末尾  如果需要在一个caddyfile文件中对多个站点进行配置，那么则必须使用{}对每一个站点进行分割
mysite.com { root /www/mysite.com } sub.mysite.com { root /www/sub.mysite.com gzip log ../access.log }  {}的使用规则，与多个参数的指令规则一样，多余多站点，所有的配置都必须包含在站点的{}之内，不允许嵌套
对于多个站点使用共同的配置，可以使用如下的方式
localhost:8080, https://site.com, http://mysite.com { ... }  另外站点的地址可以是特殊的地址或以及使用通配符
example.com/static, *.example.com { .</description>
    </item>
    
  </channel>
</rss>